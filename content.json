{"pages":[{"title":"about","text":"","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"contact","text":"","link":"/contact/index.html"},{"title":"friends","text":"","link":"/friends/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"CSS动画之transform","text":"CSS动画之transform &emsp;&emsp;CSS 的 transform 属性用来给元素添加一些变形效果，主要包括改变元素的位置或形状，同时不影响页面的布局。使用 transform 我们可以实现一些非常炫酷的效果，比如纯CSS实现的钟表、立方体的旋转等，以提升用户体验。 平移translate &emsp;&emsp;使用平移 translate 可以改变元素的位置。可选值有： translateX()：元素沿着 x 轴方向平移；translateY()：元素沿着 y 轴方向平移；translateZ()：元素沿着 z 轴方向平移；其中，平移的单位可以是像素值 px 或百分比。需要注意的是如果设置百分比的话，元素的平移量是相对于元素自身尺寸进行的。 应用：使用平移效果可以实现在元素尺寸由内容撑开时元素的水平、垂直居中效果。语法： 沿着 x 轴方向平移 transform:translateX(平移量)；沿着 y 轴方向平移 transform:translateY(平移量)；沿着 z 轴方向平移 transform:translateZ(平移量)； 实例1：元素沿着 x 轴从父元素的左侧平移到右侧。效果为：参考代码为： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;平移Translate实例&lt;/title&gt; &lt;style&gt; .box{ width: 600px; height: 320px; margin: 50px auto; border: 5px #333 solid; } .box1{ width: 200px; height: 200px; background: #bfa; transition: .5s; } .box:hover .box1{ transform: translateX(400px); } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 旋转rotate &emsp;&emsp;使用旋转 rotate 可以改变元素的位置，可以调整元素的显示角度，以实现 3D 效果。可选值有： rotateX()：元素沿着 x 轴方向旋转；rotateY()：元素沿着 y 轴方向旋转；rotateZ()：元素沿着 z 轴方向旋转；其中，旋转的单位可以是度 deg 或圈数 (turn)。当元素设置旋转效果时，是否显示元素的背面，可以使用 backface-visibility 来设置，可选值为 hidden 和 visible。需要注意的是：每个元素自身都有一个坐标轴，一开始都处于默认状态，旋转会改变坐标轴x、y、z轴的方向。因此在与平移结合使用时需要特别注意。 应用：使用旋转效果可以实现模拟钟表等应用。语法： 沿着 x 轴方向旋转 transform:rotateX(旋转角度)；沿着 y 轴方向旋转 transform:rotateY(旋转角度)；沿着 z 轴方向旋转 transform:rotateZ(旋转角度)； 实例2：元素沿着 z 轴旋转45度。效果为：参考代码为： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;旋转rotate实例&lt;/title&gt; &lt;style&gt; .box{ width: 600px; height: 320px; margin: 50px auto; border: 5px #333 solid; overflow: hidden; } .box1{ width: 200px; height: 200px; margin: 60px auto; background: #bfa; transition: .5s; } .box:hover .box1{ /* transform: rotateZ(45deg); */ /* 这两种设置方式都可以 */ transform: rotateZ(0.125turn); } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 缩放scale &emsp;&emsp;使用缩放 scale 可以改变元素的形状尺寸。可选值有： scaleX()：元素沿着 x 轴方向缩放；scaleY()：元素沿着 y 轴方向缩放；scale()：元素沿着 x,y 轴双方向缩放；scaleZ()：元素沿着 z 轴方向缩放，但这个值用的比较少，如果用了的话要配合 3D 效果才能显示出效果；其中，旋转的单位可以是度 deg 或圈数 (turn)。当元素设置旋转效果时，是否显示元素的背面，可以使用 backface-visibility 来设置，可选值为 hidden 和 visible。需要注意的是：每个元素自身都有一个坐标轴，一开始都处于默认状态，旋转会改变坐标轴x、y、z轴的方向。因此在与平移结合使用时需要特别注意。 应用：使用旋转效果可以实现模拟钟表等应用。语法： 沿着 x 轴方向缩放 transform:scaleX(缩放比例)；沿着 y 轴方向缩放 transform:scaleY(缩放比例)；沿着 x,y 轴双方向缩放 transform:scale(缩放比例)； 实例3：元素沿着 x 轴放大2倍。效果为：参考代码为： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;旋转rotate实例&lt;/title&gt; &lt;style&gt; .box{ width: 600px; height: 320px; margin: 50px auto; border: 5px #333 solid; overflow: hidden; } .box1{ width: 200px; height: 200px; margin: 60px auto; background: #bfa; transition: .5s; } .box:hover .box1{ transform: scaleX(2) } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; transform参考原点 &emsp;&emsp;变形效果的原点使用 transform-origin 来设置。默认情况下，变形效果的原点是元素的中心，也就是值为 center。可选值为： center 默认值，变形效果参考原点为元素的中心；使用方位词 left、right、top、bottom 及其组合，如果是单一方位词，则第二个值默认是center；使用像素值指定； 语法： transform-origin: value1 value2。 练习练习1：使用旋转实现钟表。&emsp;&emsp;最终效果为&emsp;&emsp;练习图片资源下载&emsp;&emsp;参考代码： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;CSS Clock&lt;/title&gt; &lt;/head&gt; &lt;style&gt; .clock { width: 400px; height: 400px; margin: 100px auto; border-radius: 50%; border: 5px #000 solid; position: relative; background-image: url(./img/img/13/bg.png); background-size: cover; } .hour-wrapper { width: 250px; height: 250px; position: absolute; left: 0; right: 0; top: 0; bottom: 0; margin: auto; animation: run 1440s infinite; } .hour { width: 6px; height: 50%; background: rgb(15, 15, 15); margin: 0 auto; } .min-wrapper { width: 300px; height: 300px; position: absolute; left: 0; right: 0; top: 0; bottom: 0; margin: auto; animation: run 120s infinite; } .min { width: 4px; height: 50%; background: rgb(37, 182, 102); margin: 0 auto; } .sec-wrapper { width: 350px; height: 350px; position: absolute; left: 0; right: 0; top: 0; bottom: 0; margin: auto; animation: run 2s infinite steps(60); } .sec { width: 2px; height: 50%; background: rgb(122, 24, 202); margin: 0 auto; } @keyframes run { from{ transform: rotateZ(0); } to{ transform: rotateZ(360deg); } } &lt;/style&gt; &lt;body&gt; &lt;div class=&quot;clock&quot;&gt; &lt;!-- 设置时针 --&gt; &lt;div class=&quot;hour-wrapper&quot;&gt; &lt;div class=&quot;hour&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- 设置分针 --&gt; &lt;div class=&quot;min-wrapper&quot;&gt; &lt;div class=&quot;min&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- 设置秒针 --&gt; &lt;div class=&quot;sec-wrapper&quot;&gt; &lt;div class=&quot;sec&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 练习2：使用6张复仇者联盟图片构建一个立方体，并实现立方体的旋转。&emsp;&emsp;最终效果为&emsp;&emsp;练习图片资源下载： 图片一： https://s1.imagehub.cc/images/2020/12/19/1.jpg； 图片二： https://s1.imagehub.cc/images/2020/12/19/2.jpg； 图片三： https://s1.imagehub.cc/images/2020/12/19/3.jpg； 图片四： https://s1.imagehub.cc/images/2020/12/19/4.jpg； 图片五： https://s1.imagehub.cc/images/2020/12/19/5.jpg； 图片六： https://s1.imagehub.cc/images/2020/12/19/6.jpg &emsp;&emsp;参考代码： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;立方体旋转&lt;/title&gt; &lt;style&gt; html { perspective: 800px; } .cube { width: 200px; height: 200px; margin: 200px auto; position: relative; transform-style: preserve-3d; animation: rotate 2s linear infinite; } .cube&gt;div { width: 200px; height: 200px; opacity: 0.7; position: absolute; } img { vertical-align: top; } .box1 { transform: rotateY(90deg) translateZ(100px); } .box2 { transform: rotateY(-90deg) translateZ(100px); } .box3 { transform: rotateX(90deg) translateZ(100px); } .box4 { transform: rotateX(-90deg) translateZ(100px); } .box5 { transform: rotateY(180deg) translateZ(100px) } .box6 { transform: rotateY(0deg) translateZ(100px); } @keyframes rotate { form{ transform:rotateX(0) rotateZ(0) } to{ transform:rotateX(1turn) rotateZ(1turn) } } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;cube&quot;&gt; &lt;div class=&quot;box1&quot;&gt; &lt;img src=&quot;./img/img/14/1.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;box2&quot;&gt; &lt;img src=&quot;./img/img/14/2.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;box3&quot;&gt; &lt;img src=&quot;./img/img/14/3.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;box4&quot;&gt; &lt;img src=&quot;./img/img/14/4.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;box5&quot;&gt; &lt;img src=&quot;./img/img/14/5.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;box6&quot;&gt; &lt;img src=&quot;./img/img/14/6.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;","link":"/2020/1219/9f5fc182.html"},{"title":"CSS动画效果之transition、animation","text":"CSS动画效果之transition、animation过渡效果transition &emsp;&emsp;过渡（transition）效果指的是CSS属性从一个值变到另一个值时的切换方式，使用过渡可以创建一些非常好的效果，提升用户的体验。&emsp;&emsp;过渡效果设置步骤：&emsp;&emsp;1、在想加过渡效果的元素中设置过渡的起点和过渡效果的实现方式；&emsp;&emsp;2、在触发过渡行为时设置过渡的终点。&emsp;&emsp;设置过渡效果的属性： transition-property：指定要执行过渡的属性，多个属性之间用英文逗号分隔。在CSS中，绝大多数属性都是可以设置过渡效果的（实际上可以理解为只要能设置具体数值的属性都可以设置过渡效果）。如果所有属性都要设置过渡效果，则可以使用关键字all。 transition-duration：指定过渡效果执行的时间，时间单位可以是秒（s）或毫秒（ms）。其中，1s = 1000ms。 transition-timing-function：设置过渡效果执行的时序函数，也就是设置过渡效果的执行方式。 可选值有：1、 ease：默认值，过渡效果慢速开始，即先加速，再减速；2、 linear：线性执行，即过渡效果匀速运动；3、 ease-in：过渡效果加速运动；4、 ease-out：过渡效果减速运动；5、 ease-in-out：过渡效果先加速后减速；6、 cubic-bezier()：使用贝塞尔曲线设置过渡方式，值的设定请查阅https://cubic-bezier.com；7、 steps(step, end/start)：分布执行过渡效果，将过渡效果从时间上划分为transition-duration / step这几个时间间隔。其中，第一个值是过渡的步数，第二个值可以是 end 或 start，end 是默认值。第二个值设为end表示分步过渡效果在时间间隔结束时执行；如果设置为start，则表示过渡效果在时间间隔刚开始时就执行。例如，transition-duration为2s，steps(2,end)，表示的是在总共分两步完成过渡，第一步在1s刚结束时发生，第二步在2s刚结束时发生；start则相反。 transition-delay：设置过渡效果在触发时，还要延迟多久再发生。 过渡效果的简写属性：transition 是过渡效果的简写属性，上面的所有属性都可以简写在该属性中，属性之间用空格隔开即可，并且属性之间无顺序要求，只要注意如果要设置过渡延迟效果的话，则延迟时间是第二个时间。 动画animation &emsp;&emsp;动画（animation）和过渡十分相似，不同的是在默认情况下它不需要指定触发行为就可以发生。&emsp;&emsp;动画的使用步骤： 设置动画关键帧； 在需要添加动画的元素中设置动画。&emsp;&emsp;关键帧设置语法：使用keyframes关键字设置,name是动画名字。 @keyframes name { /* from表示动画的开始位置（状态） 也可以使用 0% */ from{ margin-left: 0; background-color: orange; } /* to动画的结束位置（状态） 也可以使用100%*/ to{ background-color: red; margin-left: 700px; } } 动画animation的详细属性： animation-name：要设置的动画的名字，这个名字从创建关键帧时的名字中选取。 animation-duration：设置动画的执行时间。 animation-delay：设置动画执行之前的延迟时间。 animation-timing-function：设置动画执行的方式（以上四个动画属性和过渡效果的属性用法一致）。 animation-iteration-count：设置动画执行的次数，值可以是阿拉伯数字或 infinite 无限执行。 animatio-direction：指定动画执行的方向。 可选值有：1、 normal 默认值，从from向to方向执行，每次都是这样；2、 reverse 从to向from方向执行；3、 alternate 从from向to方向交替执行；4、 alternate-reverse 从to向from方向交替执行。 animation-play-state：设置动画的状态，可选值有 running 默认值，动画执行以及 paused 动画暂停。 animation-fill-mode：动画的填充模式。 可选值有：1、 none 默认值，动画执行完毕元素会回到原来的位置，但需要注意的是，动画延时等待时，元素不会处于关键帧开始状态，而是原来状态；2、 forwards 动画执行完毕后元素会停在动画结束的位置；3、 backwards 动画执行完毕时，停留在开始位置。但需要注意的是，动画延时等待时，元素就会处于关键帧开始状态。4、 both 结合了forwards和backwards，即延时等待时，元素就处于关键帧开始状态，动画结束时，元素停留在动画最后一帧。 动画的简写属性 animation，用法和过渡效果一致，详细属性无顺序要求，注意两个时间的顺序即可。 练习练习1：使用transition实现米兔行走的效果&emsp;&emsp;最终效果为&emsp;&emsp;练习图片资源下载&emsp;&emsp;参考代码： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .rabbit{ width: 132px; height: 271px; margin: 50px auto; background-image: url(./img/img/11/bigtap-mitu-queue-big.png); background-position: 0 0; transition: all steps(3) 0.2s; } .rabbit:hover{ background-position: -396px 0; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;rabbit&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 练习2：实现卡通人物的奔跑效果。&emsp;&emsp;最终效果为&emsp;&emsp;练习图片资源下载&emsp;&emsp;参考代码： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box1{ width: 256px; height: 256px; margin: 50px auto; background-image: url(./img/img/12/bg2.png); animation: run 3s steps(6) infinite; } @keyframes run { from{ background-position: 0 0; } to{ background-position: -1536px 0; } } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt;","link":"/2020/1218/c4a5188e.html"},{"title":"前端概述","text":"网站逻辑介绍前端分为客户端与服务器。其中，客户端是通过浏览器解析前端工程师所写的网页源码来实现（我们日常的上网所浏览的网页都是基于这个逻辑的），服务器主要处理前端的请求并返回结果响应。前端页面所涉及的核心技术为HTML（超文本标记语言）、CSS（层叠样式表）和JavaScript。其中，HTML是网页骨架，CSS控制网页的显示样式，JavaScript控制网页的行为（这三种技术一般称为“结构—样式—行为”）。 前端学习路线学习Web开发一般可以按照先学HTML，然后学习CSS，最后再学Javascript这样的顺序进行。当然，需要注意的是，初学阶段，在学习HTML时，主要以对各个标签熟悉为主。对于暂时理解不了的知识不要过于纠结，随着学习的深入这些疑问才能慢慢理解，比如HTML表单，在没有学习JavaScript以及后端的知识时，很难完全理解表单的运行逻辑；在学习CSS时，同样是以熟悉各个CSS熟悉为主，不必要求一下子要记住所有的属性，但务必要将各个属性的原理理解清楚，比如外边距折叠、高度塌陷等问题是怎么产生的；到了学习JavaScript时，不仅要学习它的理论知识，还要勤于动手，在练习实践中学习、理解知识。 最后，在学习这三部分内容时，一定要耐下心来，把每个知识点都过一遍，多多练习。这三部分知识是整个网页前端的基础和核心。","link":"/2020/1215/dbc0e3b9.html"},{"title":"Hexo快速开始","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","link":"/2021/0814/ebeb7b66.html"},{"title":"Markdown使用","text":"Markdown使用Markdown标题 使用’ = ‘和’ - ‘标记一级标题和二级标题我展示的是一级标题（只要下方有一个等号即可） 我展示的是二级标题 使用’ # ‘号的个数来标记标题的级别，有1~6这六个级别的标题，#个数越多，代表标题级别越低。 Markdown段落Markdown段落没有特殊的格式，直接编写文字就好。段落换行：使用两个以上的空格加回车，然后在该行输入文字，即可实现段落的换行。注意，这种做法是实现换行，两行之间并没有空一行；两行之间空一行：输入文字时在两行之间空一行。 Markdown字体 斜体 使用两个星号*将文字包裹起来，可实现斜体； 使用英文输入法的两个下划线_也可实现斜体； 文本加粗 左右均使用两个星号*包裹文字，可实现文字加粗效果； 左右均使用英文输入法的两个下划线_也可实现文本的加粗效果。 粗斜体文本 左右各使用三个星号*将文字包裹，可实现粗斜体文本； 左右各使用英文输入法的三个下划线_，也可实现粗斜体文本。 分割线你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。 下划线下划线可以通过 HTML 的 u 标签来实现： Markdown列表Markdown 支持有序列表和无序列表。 无序列表无序列表使用星号、加号或是减号作为列表标记，这些标记后面要添加一个空格，然后再填写内容： 有序列表有序列表使用数字并加上 . 号来表示，如： 列表嵌套列表嵌套只需在子列表中的选项前面添加四个空格即可： 删除线使用HTML的del标签实现。删除文字 Markdown区块Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号。另外区块是可以嵌套的，一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推。 区块中使用列表具体用法见下面实例： 列表中使用区块如果要在列表项目内放进区块，那么就需要在 &gt; 前添加四个空格的缩进。区块中使用列表实例如下： Markdown代码 如果是段落上的一个函数或片段的代码可以用反引号把它包起来（`）。 代码区块：代码区块使用 4 个空格或者一个制表符（Tab 键）来包裹代码；也可以使用三对反引号来包裹代码块。 Markdown链接链接的使用方法为：[链接名称](链接地址)或&lt;链接地址&gt;，两个实例分别为：徐齐胜的博客、https://qishengx.github.io/高级链接：通过变量来设置链接，变量赋值在文档末尾进行。一个实例为： Markdown图片Markdown语法格式为： 开头一个感叹号 !; 接着一个方括号，里面放上图片的替代文字; 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 ‘title’ 属性的文字。当然，你也可以像网址那样对图片网址使用变量:Markdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的 &lt;img&gt; 标签。 Markdown表格 Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。语法格式如下： 表格对齐方式我们可以设置表格的对齐方式：-: 设置内容和标题栏居右对齐。:- 设置内容和标题栏居左对齐。:-: 设置内容和标题栏居中对齐。实例如下： Markdown高级技巧 支持HTML元素：不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。 转义：Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠 \\ 转义特殊字符。 参考- [1] 菜鸟教程","link":"/2020/1216/28cddff3.html"},{"title":"Windows系统下mongoDB安装教程","text":"Windows系统下mongoDB安装教程&emsp;&emsp;MongoDB是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。在高负载的情况下，添加更多的节点，可以保证服务器性能。&emsp;&emsp;MongoDB旨在为WEB应用提供可扩展的高性能数据存储解决方案。它将数据存储为一个文档，数据结构由键值(key=&gt;value)对组成。MongoDB文档类似于JSON对象。字段值可以包含其他文档，数组及文档数组。 MongoDB下载 &emsp;&emsp;根据自己机器的配置选择合适的版本，从mongoDB官网下载安装包，下载地址为https://www.mongodb.com/try/download/community?jmp=nav。 mongoDB安装 &emsp;&emsp;1. 官网下载得到MongoDB安装包.msi文件，双击文件启动安装向导，界面如图所示：&emsp;&emsp;2. 直接next；&emsp;&emsp;3. 勾选接受协议，点击next；&emsp;&emsp;4. 选择自定义安装，如图红色箭头所示；&emsp;&emsp;5. 根据自己的情况选择是否更改安装路径；&emsp;&emsp;6. 从MongoDB 4.0开始，您可以在安装期间将MongoDB设置为服务，或者只安装二进制文件。 MongoDB服务以下是安装和配置MongoDB作为服务。从MongoDB 4.0开始，您可以在安装期间配置和启动MongoDB作为服务，并在成功安装后启动MongoDB服务。选择将MongoD安装为服务。Run the service as Network Service user以网络服务用户身份运行服务（默认）,这是Windows内置的Windows用户帐户。或者Run the service as a local or domain user以本地或域用户身份运行服务： 对于现有的本地用户帐户，请指定一个句点作为帐户域（即.），并为该用户指定帐户名称和帐户密码。 对于现有域用户，请为该用户指定“帐户域”，“帐户名”和“帐户密码”。 服务名称：指定服务名称。默认名称是MongoDB。如果您已拥有具有指定名称的服务，则必须选择另一个名称。数据目录：指定数据目录，对应于 –dbpath。如果该目录不存在，安装程序将创建该目录并设置对服务用户的目录访问权限。日志目录：指定日志目录，该目录对应于 –logpath。如果该目录不存在，安装程序将创建该目录并设置对服务用户的目录访问权限。 只安装MongoDB以下仅安装MongoDB，不将MongoDB配置为服务。如果您选择不将MongoDB配置为服务，请取消选中Install MongoD as a Service。 &emsp;&emsp;7.安装MongoDB Compass(界面化数据库管理工具)。对于Windows 8或更高版本，您可以让向导安装 MongoDB Compass。要安装Compass，请选择Install MongoDB Compass（默认）。&emsp;&emsp;8.点击next，下面默认运行即可完成MongoDB。 MongoDB配置 创建C:\\Program Files\\MongoDB\\data\\log目录，用来存放日志文件； 在C:\\Program Files\\MongoDB\\data\\log目录里新建mongodb.log，用来存放日志信息； 创建C:\\Program Files\\MongoDB\\data\\db目录，用来存放数据库数据， 并在D:\\mongodb目录下创建mongo.config，在文件内部复制如下文本： ##数据文件 此处=后对应到数据所存放的目录 dbpath=C:\\Program Files\\MongoDB\\data\\db ##日志文件 此处=后对应到日志文件所在路径 logpath=C:\\Program Files\\MongoDB\\data\\log\\mongodb.log ##错误日志采用追加模式，配置这个选项后mongodb的日志会追加到现有的日志文件，而不是从新创建一个新文件 logappend=true #启用日志文件，默认启用 journal=true #这个选项可以过滤掉一些无用的日志信息，若需要调试使用请设置为false quiet=true #端口号 默认为27017 port=27017 测试是否安装成功进入MongoDB安装目录的bin目录下，运行mongod.exe，如果闪一下退出就说明安装成功。在浏览器窗口输入localhost:27017，会出现下图：","link":"/2021/0118/8e30dd64.html"},{"title":"基于Python+selenium实现自动填写表单","text":"基于Python+selenium实现自动填写表单背景介绍&emsp;&emsp;在实际工作中，经常会遇到这样的需求——将客户信息录入公司内部的后台管理系统。如果客户信息少的话，人工录入似乎也没什么问题。然而，当客户信息很多时，如果还是人工录入的话，显然耗时耗力，甚至会意外导致客户信息录入错误。为了避免繁琐、重复的操作步骤，同时避免不必要的错误，我们可以借助Python和selenium写一个自动化脚本来满足这一需求！ 工具准备 安装Python语言（建议使用Anaconda方式进行安装，下面介绍基于此方式）； 安装selenium库，使用命令pip install selenium； 安装与浏览器版本相对应的浏览器驱动程序，以Google浏览器为例： 1） 查看浏览器版本号：打开Google浏览器，在地址栏输入chrome://version/，便可以查看到浏览器的版本号，下图中红色矩形框中的便是版本号：2） 下载Google浏览器对应版本的驱动程序，下载地址为https://chromedriver.storage.googleapis.com/index.html3） 将下载的驱动文件解压，并将里面的chromedriver.exe程序放置到Anaconda安装目录的Scripts文件夹下，以笔者的为例：D:\\ProgramData\\Anaconda3\\Scripts 代码实现 完成了工具准备以后，便可以开始使用代码实现需求了，以百度自动搜索selenium为例，请看示例代码： # encoding=utf8 from selenium import webdriver from selenium.webdriver.common.desired_capabilities import DesiredCapabilities import time # 前台开启浏览器模式 def openChrome(): # 加启动配置 option = webdriver.ChromeOptions() option.add_argument('disable-infobars') # 打开chrome浏览器 driver = webdriver.Chrome(chrome_options=option) return driver # 授权操作 def operationAuth(driver): url = &quot;http://www.baidu.com&quot; driver.get(url) # 找到输入框并输入查询内容 elem = driver.find_element_by_id(&quot;kw&quot;) elem.send_keys(&quot;selenium&quot;) # 提交表单 driver.find_element_by_xpath(&quot;//*[@id='su']&quot;).click() print('查询操作完毕！') # 方法主入口 if __name__ == '__main__': # 加启动配置 driver = openChrome() operationAuth(driver) 一些命令的说明： driver.get(url)：使用浏览器打开目标url；driver.find_element_by_id(&quot;kw&quot;)： 根据网页标签中HTML元素的id属性进行元素定位，本示例中定位的依据是百度搜索引擎搜索框的id，即字符串kw；elem.send_keys(&quot;selenium&quot;)： 向搜索框中填入搜索关键字selenium；driver.find_element_by_xpath(&quot;//*[@id='su']&quot;).click()： 一种新的定位元素的方式，基于xpath进行定位，这句代码前一部分是定位到了“百度一下”那个按钮，后一部分是点击操作，模拟用户的点击行为。说明：对于使用xpath方式定位，如何获取HTML元素的xpath问题，打开目标页面，按F12或右键—检查，然后用鼠标定位到目标元素，在浏览器的Elements视口中，右键目标元素—copy—copy-XPath便可以获取目标元素的XPath值。","link":"/2021/0814/df93fdb0.html"},{"title":"matery主题下Markdown常用编程语言代码块规范","text":"python代码# encoding=utf8 from selenium import webdriver from selenium.webdriver.common.desired_capabilities import DesiredCapabilities import time # 前台开启浏览器模式 def openChrome(): # 加启动配置 option = webdriver.ChromeOptions() option.add_argument('disable-infobars') # 打开chrome浏览器 driver = webdriver.Chrome(chrome_options=option) return driver # 授权操作 def operationAuth(driver): url = \"http://www.baidu.com\" driver.get(url) # 找到输入框并输入查询内容 elem = driver.find_element_by_id(\"kw\") elem.send_keys(\"selenium\") # 提交表单 driver.find_element_by_xpath(\"//*[@id='su']\").click() print('查询操作完毕！') # 方法主入口 if __name__ == '__main__': # 加启动配置 driver = openChrome() operationAuth(driver) CSS代码@keyframes name &amp;#123; /* from表示动画的开始位置（状态） 也可以使用 0% */ from&amp;#123; margin-left: 0; background-color: orange; &amp;#125; /* to动画的结束位置（状态） 也可以使用100%*/ to&amp;#123; background-color: red; margin-left: 700px; &amp;#125; &amp;#125; HTML代码&lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> &lt;title>Document&lt;/title> &lt;style> .rabbit&amp;#123; width: 132px; height: 271px; margin: 50px auto; background-image: url(./img/img/11/bigtap-mitu-queue-big.png); background-position: 0 0; transition: all steps(3) 0.2s; &amp;#125; .rabbit:hover&amp;#123; background-position: -396px 0; &amp;#125; &lt;/style> &lt;/head> &lt;body> &lt;div class=\"rabbit\">&lt;/div> &lt;/body> &lt;/html>","link":"/2021/0817/df93fdb0.html"},{"title":"算法的时间复杂度","text":"什么是时间复杂度&emsp;&emsp;所谓算法的时间复杂度，指的就是在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数。 时间复杂度的计算&emsp;&emsp;时间复杂度就是语句总的执行次数T(n)是关于问题规模n的函数。那么我们计算时间复杂度就相当于去分析T(n)随n的变化情况并确定T(n)的数量级，记作：T(n)=O(f(n))&emsp;&emsp;该式就表示了随着问题规模的增大，算法执行时间的增长率和函数f(n)的增长率相同，从而研究时间复杂度就等同于研究函数f(n)，严格来说，我们把当问题规模n取无穷大时，函数的最高次数项就称为算法的时间复杂度。 常见算法时间复杂度的计算&emsp;&emsp;我们以计算1+2+…+n为例分析。 使用for循环#include \"stdio.h\" int main() { int i, sum = 0, n = 100; /* 执行1次 */ for( i = 1; i","link":"/2021/0822/6dba3ed0.html"},{"title":"C++使用OpenMp并行记录","text":"概述Visual Studio2019已内置支持OpenMP，但在使用之前还需要做一些配置。 具体步骤（以控制台应用程序为例） 创建项目创建一个控制台应用程序，并在.cpp文件中输入以下测试代码``` C++#include &lt;omp.h&gt; //引入openMP头文件#include using namespace std; int main(){#pragma omp parallel { cout &lt;&lt; “Hello World!\\n”; }} 如果这时直接编译运行会报以下错误，所以需要对项目进行配置： ``` bash c1xx: error C2338: two-phase name lookup is not supported for C++/CLI, C++/CX, or OpenMP; use /Zc:twoPhase- c1xx: fatal error C1903: unable to recover from previous error(s); stopping compilation error MSB6006: &quot;CL.exe&quot; exited with code 2 配置项目在项目属性中，进行如下三处配置： 验证是否成功启动项目，可以在控制台看到以下内容，表明配置成功。","link":"/2021/0916/1ed4658b.html"},{"title":"CentOS7配置MPI集群","text":"集群设计本次搭建共使用三台机器，系统为CentOS7，其中一台作为管理节点，负责登录；另外两台分别作为计算节点，负责执行并行程序。机器配置如下：| 节点名称 | 节点IP地址 | 核数 || —- | —- | —- || mu01 | 192.168.84.130 | 2 || cu01 | 192.168.84.131 | 2 || cu02 | 192.168.84.129 | 2 | 节点设置 配置节点的IP地址配置每个节点的 IP 地址，过程如下：首先，使用ip addr查看网卡名，如图红框中即为该机的网卡名。使用vi /etc/sysconfig/network-scripts/ifcfg-{网卡名}编辑网卡配置文件，添加或修改如下配置：配置后重启网卡，使其生效，其中 IPADDR 的值按上表进行填写，systemctl restart network 主机名配置 设置三个节点的主机名分别为mu01、cu01、cu02，使用hostnamectl set-hostname 主机名设置。 修改/etc/hosts文件实现主机名与ip地址对应，在每个节点的hosts文件中加入：``` 168.100.10 mu01 168.100.11 cu01 168.100.12 cu02```配置完成后重启，source /etc/hosts，此时各节点可通过ssh 节点名互访。 MPI 环境安装MPI 并不是一种新的开发语言，它是一个定义了可以被 C、C++ 和 Fortran 程序调用的函数库。它有多种实现，本次使用的是 mpich 的 MPI 实现，此外还有 openmpi、intelmpi 等实现。 在管理节点mu01上安装 MPI 环境： 安装 gcc 编译器yum install gcc gcc-c++ gcc-gfortran 下载安装 mpichwget http://www.mpich.org/static/downloads/3.3/mpich-3.3.tar.gz tar -xzvf mpich-3.3.tar.gz cd mpich-3.3 ./configure --prefix=/opt/mpich make make install 其中，make和make install两条指令可以合并为一条写make &amp;&amp; make install。 设置环境变量编辑 ~/bashrcvi ~/bashrc，添加以下内容：export PATH=/opt/mpich/bin/:%PATH 设置完以后使用which mpicc、which mpiexec检测是否安装配置成功。结果如下说明配置成功： 在mu01上测试MPI编写测试程序 vi mpitest.c#include &lt;mpi.h&gt; #include &lt;stdio.h&gt; int main (int argc, char* argv[]) { int rank, size; MPI_Init (&amp;argc, &amp;argv); /* starts MPI*/ MPI_Comm_rank (MPI_COMM_WORLD, &amp;rank); /* get current process id*/ MPI_Comm_size (MPI_COMM_WORLD, &amp;size); /* get number of processes*/ printf( &quot;Hello world from process %d of %dn&quot;, rank, size ); MPI_Finalize(); return 0; } 使用管理节点单个节点运行MPI程序进行测试：mpicc mpitest.c -o hello # 编译 mpiexec -np 5 ./hello # 执行 编译运行结果如下：Hello world from process 4 of 5 Hello world from process 2 of 5 Hello world from process 3 of 5 Hello world from process 0 of 5 Hello world from process 1 of 5 注意：一般情况下，管理节点只进行程序编译与提交任务，不建议在管理节点运行计算程序。 ＃ NFS 安装由于 MPICH 的安装目录和用户可执行程序在并行计算时需要在所有节点存副本，而且目录要相互对应，每次一个节点一个节点地复制非常麻烦，采用 NFS 文件系统可以实现所有节点内容与管理节点内容同步更新，并自动实现目录的对应。 对于仅包含几个结点的较小的集群系统，可以任意指定其中一个结点作为 NFS 服务器。对较大的集群系统，最好设定一个或数个结点专门用于文件服务，这些结点称为 I/O 结点，它们专门负责存储设备的管理，不参加计算。这里选择 mu01 作为 NFS 服务器，将它的/home 和/opt 目录输出给其他三个结点。 1. 在每个节点上安装 NFS 所需软件包并设置为开机启动 yum install nfs-utils rpcbind systemctl enable rpcbind.service # 设置开机启动 systemctl enable nfs-server.service systemctl start rpcbind.service # 启动服务 systemctl start nfs-server.service 注意：上述操作依次执行。2. 在mu01节点配置共享目录 vi /etc/exports # 添加以下内容 /home *(async,insecure,rw,no_all_squash,no_root_squash) # 将mu01的home目录设置为共享目录 /opt *(async,insecure,rw,no_all_squash,no_root_squash) # 将mu01的opt目录设置为共享目录 刷新 NFS 设置：exportfs -ra 查看 NFS 状态：exportfs -v注意：设置opt目录为共享目录后，其他节点就不需要重新安装mpi环境了，只需安装运行mpi所需的依赖库就行（后续会具体说到）3. 在子节点 cu01 和 cu02 上挂载 NFS，查看可挂载目录 showmount -e mu01。挂载 opt 与 home 目录： mount -t nfs mu01:/opt /opt mount -t nfs mu01:/home /home 设置开机自动挂载：追加下面配置到/etc/fstab mu01:/home /home nfs defaults,nfsvers=3 0 0 mu01:/opt /opt nfs defaults,nfsvers=3 0 0 df -h 查看是否挂载成功，成功输出如下： 子节点 cu01 和 cu02 上MPI环境搭建前面我们已经将 mu01 的/opt 目录设置为共享目录，因此子节点无需重新安装mpi，只需将MPI程序的运行依赖安装上即可，即安装 gcc 编译器，在子节点中分别运行如下命令。 yum install gcc gcc-c++ gcc-gfortran 进入/opt/mpich/share cd /opt/mpich/share，编写测试程序mpitest.c vi mpitest.c，内容与之前一样，编译运行，如果能成功执行说明子节点MPI环境配置成功。 NIS 安装集群中的每台主机都需要设计相同的帐号密码是非常麻烦的，因此可通过一个 NIS 主控制服务器管理集群中所有帐号密码,当其他主机有登录需求时再向主控制服务器请求相关账户信息。以 mu01 结点当作 NIS 主控制结点为服务端，cu 结点为客户端。 安装相关软件服务端： yum install ypserv rpcbind客户端： yum install ypbind NIS 服务端配置 设定 NIS 局域网名称：编辑/etc/sysconfig/network 加入配置 NISDOMAIN=mu 设置主要配置文件：编辑 NIS 配置文件/etc/ypserv.conf，允许特定的主机访问 NIS 服务器,在查询权限部分加入：``` 127.0.0.0/255.255.255.0 : * : * : none192.168.84.0/255.255.255.0 : * : * : none : * : * : deny ``` 启动 NIS 与设置开机启动systemctl start ypserv systemctl enable ypserv 使用 rpcinfo -u localhost ypserv检测是否启动成功。 建立用户资料库执行命令 /usr/lib64/yp/ypinit -m建立数据库，在我们的集群环境中，只有mu01一个管理节点，直接按 ctrl D + 回车即设置完毕，将 nis 服务器端的用户信息导入，当用户信息更新时，也需重新执行该命令更新数据库。建立完数据库后，需要将服务重启 systemctl restart ypserv。 NIS 客户端配置 设置 NIS 网域名称与服务端操作相同 修改用户密码的认证顺序 vim /etc/nsswitch.conf 修改以下配置：passwd: files nis shadow: files nis group: files nis hosts: files nis dns 修改客户端配置文件: 配置/etc/yp.conf，添加 domain mu server mu01 修改系统认证文件: vim /etc/sysconfig/authconfig，修改 USENIS=yes；vim /etc/pam.d/system-auth，修改 password sufficient pam_unix.so sha512 shadow nis nullok try_first_pass use_authtok。 启动服务并设置为开机启动systemctl start ypbind systemctl enable ypbind 在 NIS client 输入 yptest 测试是否配置成功。 配置SSH免密登录MPI 并行程序运行时需要设计多机互访免密码，因此下面进行ssh免密登录配置 配置 mu01 免密登录 cu01 和 cu02。 生成公钥和授权文件ssh-keygen -t rsa # 该命令一路回车即可，会在~/.ssh/下生成两个文件 cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys # 将上一步生成的公钥文件复制到authorized_keys授权文件中 chmod 700 .ssh # 设置authorized_keys的权限，下同 chmod 600 .ssh/authorized_keys 将授权文件复制给子节点scp ~/.ssh/authorized_keys root@cu01:~/.ssh/ scp ~/.ssh/authorized_keys root@cu02:~/.ssh/ 此时，输入 ssh cu01，会提示输入cu01的密码，输入这一次即可，以后再从mu01切换到cu01就不用再输密码了；cu02操作同cu01。 依次配置子节点和其他节点之间的免密登录，在本示例中，还需配置 cu01 与 mu01、cu02 以及 cu02 与 mu01、cu01之间的免密登录，全部配置好后即可实现三台机器互相免密登录。 多机运行MPI程序在mu01节点的/opt/mpich/share/中编写文件mpi_duoji_test.c，输入： #include &lt;mpi.h&gt; #include &lt;stdio.h&gt; #include &lt;math.h&gt; int main(argc,argv)int argc;char *argv[]; { int myid,numprocs; int namelen; char processor_name[MPI_MAX_PROCESSOR_NAME]; MPI_Init(&amp;argc, &amp;argv); MPI_Comm_rank(MPI_COMM_WORLD, &amp;myid); MPI_Comm_size(MPI_COMM_WORLD, &amp;numprocs); MPI_Get_processor_name(processor_name,&amp;namelen); fprintf(stderr,&quot;Hello World!process %d of %d on %s\\n&quot;,myid,numprocs,processor_name); MPI_Finalize(); return 0; } 然后依次运行如下命令： mpicc mpi_duoji_test.c -o ./hello # 编译 mpiexec -hosts cu01,cu02 -np 8 ./hello 运行结果为：说明程序已在多机上运行。","link":"/2021/1118/3d983c74.html"}],"tags":[{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"Web","slug":"Web","link":"/tags/Web/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"文本编辑","slug":"文本编辑","link":"/tags/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91/"},{"name":"mongoDB","slug":"mongoDB","link":"/tags/mongoDB/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"软件安装教程","slug":"软件安装教程","link":"/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"},{"name":"Web自动化","slug":"Web自动化","link":"/tags/Web%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"selenium","slug":"selenium","link":"/tags/selenium/"},{"name":"算法效率","slug":"算法效率","link":"/tags/%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"OpenMP","slug":"OpenMP","link":"/tags/OpenMP/"},{"name":"MPI","slug":"MPI","link":"/tags/MPI/"},{"name":"集群","slug":"集群","link":"/tags/%E9%9B%86%E7%BE%A4/"}],"categories":[{"name":"CSS","slug":"CSS","link":"/categories/CSS/"},{"name":"Web","slug":"Web","link":"/categories/Web/"},{"name":"教程","slug":"教程","link":"/categories/%E6%95%99%E7%A8%8B/"},{"name":"Markdown","slug":"Markdown","link":"/categories/Markdown/"},{"name":"MongoDB","slug":"MongoDB","link":"/categories/MongoDB/"},{"name":"自动化","slug":"自动化","link":"/categories/%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"name":"Markdown","slug":"教程/Markdown","link":"/categories/%E6%95%99%E7%A8%8B/Markdown/"},{"name":"程序设计","slug":"程序设计","link":"/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"},{"name":"并行化","slug":"并行化","link":"/categories/%E5%B9%B6%E8%A1%8C%E5%8C%96/"}]}